Claro! Vamos renomear a interface `IUserSessionRepository` para `TokenSessionAdapter` e ajustar o código conforme necessário.

### 1. **Renomear a Interface**

Renomeie a interface para `TokenSessionAdapter`:

```csharp
public interface TokenSessionAdapter
{
    Task<UserTokenSession> GetSessionAsync(int userId);
    Task SaveSessionAsync(UserTokenSession session);
}
```

### 2. **Implementar Adapters para Diferentes Armazenamentos**

Implemente a interface para diferentes tipos de armazenamento. Aqui estão exemplos para banco de dados, Azure Table Storage e MongoDB:

#### Banco de Dados

```csharp
public class DatabaseTokenSessionAdapter : TokenSessionAdapter
{
    private readonly AppDbContext _context;

    public DatabaseTokenSessionAdapter(AppDbContext context)
    {
        _context = context;
    }

    public async Task<UserTokenSession> GetSessionAsync(int userId)
    {
        return await _context.UserTokenSessions.SingleOrDefaultAsync(ts => ts.UserId == userId);
    }

    public async Task SaveSessionAsync(UserTokenSession session)
    {
        var existingSession = await _context.UserTokenSessions.SingleOrDefaultAsync(ts => ts.UserId == session.UserId);
        if (existingSession == null)
        {
            await _context.UserTokenSessions.AddAsync(session);
        }
        else
        {
            _context.UserTokenSessions.Update(session);
        }
        await _context.SaveChangesAsync();
    }
}
```

#### Azure Table Storage

```csharp
public class TableStorageTokenSessionAdapter : TokenSessionAdapter
{
    private readonly CloudTable _table;

    public TableStorageTokenSessionAdapter(CloudTable table)
    {
        _table = table;
    }

    public async Task<UserTokenSession> GetSessionAsync(int userId)
    {
        var retrieveOperation = TableOperation.Retrieve<UserTokenSession>("UserTokenSession", userId.ToString());
        var result = await _table.ExecuteAsync(retrieveOperation);
        return result.Result as UserTokenSession;
    }

    public async Task SaveSessionAsync(UserTokenSession session)
    {
        var insertOrReplaceOperation = TableOperation.InsertOrReplace(session);
        await _table.ExecuteAsync(insertOrReplaceOperation);
    }
}
```

#### MongoDB

```csharp
public class MongoDbTokenSessionAdapter : TokenSessionAdapter
{
    private readonly IMongoCollection<UserTokenSession> _collection;

    public MongoDbTokenSessionAdapter(IMongoDatabase database)
    {
        _collection = database.GetCollection<UserTokenSession>("UserTokenSessions");
    }

    public async Task<UserTokenSession> GetSessionAsync(int userId)
    {
        return await _collection.Find(session => session.UserId == userId).FirstOrDefaultAsync();
    }

    public async Task SaveSessionAsync(UserTokenSession session)
    {
        var existingSession = await _collection.Find(s => s.UserId == session.UserId).FirstOrDefaultAsync();
        if (existingSession == null)
        {
            await _collection.InsertOneAsync(session);
        }
        else
        {
            await _collection.ReplaceOneAsync(s => s.UserId == session.UserId, session);
        }
    }
}
```

### 3. **Criar a Fábrica de Adapters**

Implemente uma fábrica para criar instâncias dos adapters:

```csharp
public class TokenSessionAdapterFactory
{
    private readonly IServiceProvider _serviceProvider;

    public TokenSessionAdapterFactory(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    public TokenSessionAdapter CreateAdapter(string adapterType)
    {
        return adapterType switch
        {
            "Database" => _serviceProvider.GetService<DatabaseTokenSessionAdapter>(),
            "TableStorage" => _serviceProvider.GetService<TableStorageTokenSessionAdapter>(),
            "MongoDb" => _serviceProvider.GetService<MongoDbTokenSessionAdapter>(),
            _ => throw new ArgumentException("Invalid adapter type")
        };
    }
}
```

### 4. **Atualizar o Método `validateCredentials`**

Modifique o método `validateCredentials` para usar a fábrica e o adapter apropriado:

```csharp
private readonly TokenSessionAdapterFactory _adapterFactory;

public YourClass(TokenSessionAdapterFactory adapterFactory)
{
    _adapterFactory = adapterFactory;
}

private async Task<TokenVO> validateCredentials(User user)
{
    if (user == null) return new TokenVO();
    var claims = new List<Claim>
    {
        new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString("N")),
        new Claim(JwtRegisteredClaimNames.NameId, user.Id.ToString()),
        new Claim(JwtRegisteredClaimNames.Name, user.Name),
    }; 
    var accessToken = _tokenService.GenerateAccessToken(claims);
    var refreshToken = _tokenService.GenerateRefreshToken(); 

    var adapter = _adapterFactory.CreateAdapter("Database"); // ou "TableStorage", "MongoDb"
    var tokenSession = await adapter.GetSessionAsync(user.Id);
    if (tokenSession == null)
    {
        tokenSession = new UserTokenSession
        {
            UserId = user.Id,
            AccessToken = accessToken,
            RefreshToken = refreshToken,
            RefreshTokenExpiryTime = DateTime.UtcNow.AddDays(_configurationToken.DaysToExpiry),
            LastAccessDate = DateTime.UtcNow,
            CreatedDate = DateTime.UtcNow,
            ModifyDate = DateTime.UtcNow,
            ExpiresAt = DateTime.UtcNow.AddMinutes(_configurationToken.Minutes),
            Enable = true
        };
    }
    else
    {
        tokenSession.AccessToken = accessToken;
        tokenSession.RefreshToken = refreshToken;
        tokenSession.RefreshTokenExpiryTime = DateTime.UtcNow.AddDays(_configurationToken.DaysToExpiry);
        tokenSession.LastAccessDate = DateTime.UtcNow;
        tokenSession.ModifyDate = DateTime.UtcNow;
        tokenSession.ExpiresAt = DateTime.UtcNow.AddMinutes(_configurationToken.Minutes);
    }

    await adapter.SaveSessionAsync(tokenSession);

    return new TokenVO(true,
        tokenSession.CreatedDate.ToString("yyyy-MM-ddTHH:mm:ssZ"),
        tokenSession.ExpiresAt.ToString("yyyy-MM-ddTHH:mm:ssZ"),
        accessToken,
        refreshToken
    );
}
```

### 5. **Configurar a Injeção de Dependência**

Configure a injeção de dependência no `Startup`:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddScoped<DatabaseTokenSessionAdapter>();
    services.AddScoped<TableStorageTokenSessionAdapter>();
    services.AddScoped<MongoDbTokenSessionAdapter>();
    services.AddSingleton<TokenSessionAdapterFactory>();
    // Outros serviços...
}
```

Com essas alterações, você terá um sistema flexível e escalável para salvar e recuperar sessões de usuário, permitindo que a API REST seja escalável e desacoplada da lógica de armazenamento específico. Se precisar de mais ajuda ou tiver outras perguntas, estou à disposição!



Em C# .net 8 EF core codefirst e fluentapi como melhorar os metodos e ajustar para que a autenticacao seja salva no banco de dados para que a api seja possivel escalar em varias instancias e assim a sessao de login ser compartilhada  
public async Task<ServiceResponse<GetUserAuthenticatedDto>> Login(string login, string password)
{
    var response = new ServiceResponse<GetUserAuthenticatedDto>(); 
    var user = await _entityRepository.FindByLogin(login);
    if (user == null)
    {
        response.Success = false;
        response.Message = ValidatorConstants.Validade_UserNotFound;
        return response;
    }
    else if (!SecurityHelper.VerifyPasswordHash(password, user.PasswordHash, user.PasswordSalt))
    {
        response.Success = false;
        response.Message = "Wrong password.";
        return response;
    } 
    if (_configurationAuth.TypeApiCredential == ETypeApiCredential.Jwt)
    {
        response.Data = await executeLoginJwt(user);
    }
    response.Success = true;
    response.Message = "User Logged.";
    return response;
}
  private async Task<GetUserAuthenticatedDto> executeLoginJwt(User user)
  {
      TokenVO token = await validateCredentials(user);
      GetUserAuthenticatedDto response = _mapper.Map<GetUserAuthenticatedDto>(user); 
      fillRoleGroupsAuthenticate(response, user); 
      response.MedicalId = user.Medical?.Id;
      response.TokenAuth = token;
      return response;
  }  private async Task<TokenVO> validateCredentials(User user)
  {
      if (user == null) return new TokenVO();
      var claims = new List<Claim>
      {
          new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString("N")),
          new Claim(JwtRegisteredClaimNames.NameId, user.Id.ToString()),
          new Claim(JwtRegisteredClaimNames.Name, user.Name),
      }; 
      var accessToken = _tokenService.GenerateAccessToken(claims);
      var refreshToken = _tokenService.GenerateRefreshToken(); 
      user.RefreshToken = refreshToken;
      user.RefreshTokenExpiryTime = DataHelper.GetDateTimeNow().AddDays(_configurationToken.DaysToExpiry); 
      await _entityRepository.RefreshUserInfo(user); 
      DateTime createDate = DataHelper.GetDateTimeNow();
      DateTime expirationDate = createDate.AddMinutes(_configurationToken.Minutes);
      return new TokenVO(true,
          createDate.ToString(AppConfigConstants.DATE_FORMAT),
          expirationDate.ToString(AppConfigConstants.DATE_FORMAT),
          accessToken,
          refreshToken
          );
  } services.AddAuthentication(options =>
 {
     options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
     options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
 }).AddJwtBearer(options =>
 {
     options.TokenValidationParameters = new TokenValidationParameters
     {
         ValidateIssuer = true,
         ValidateAudience = true,
         ValidateLifetime = true,
         ValidateIssuerSigningKey = true,
         ValidIssuer = tokenConfigurations.Issuer,
         ValidAudience = tokenConfigurations.Audience,
         IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(tokenConfigurations.Secret))
     };
 });
 services.AddAuthorizationCore(auth =>
 {
     auth.AddPolicy("Bearer", policyBuilder =>
     {
         policyBuilder.AddAuthenticationSchemes(JwtBearerDefaults.AuthenticationScheme)
             .RequireAuthenticatedUser();
     });
 });















Vamos criar a tabela `EmailTemplates` usando o Code First com Entity Framework Core, Fluent API e FluentValidation. Aqui está um exemplo completo:

1. **Definir o modelo `EmailTemplate`:**

```csharp
public class EmailTemplate
{
    public int Id { get; set; }
    public string TemplateName { get; set; }
    public string Subject { get; set; }
    public string Body { get; set; }
}
```

2. **Configurar o modelo usando Fluent API:**

```csharp
public class ApplicationDbContext : DbContext
{
    public DbSet<EmailTemplate> EmailTemplates { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("YourConnectionString");
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<EmailTemplate>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.TemplateName)
                .IsRequired()
                .HasMaxLength(100);
           
        });
    }
}
```

3. **Adicionar validação com FluentValidation:**

```csharp
using FluentValidation;

public class EmailTemplateValidator : AbstractValidator<EmailTemplate>
{
    public EmailTemplateValidator()
    {
        RuleFor(x => x.TemplateName)
            .NotEmpty().WithMessage("Template name is required.")
            .MaximumLength(100).WithMessage("Template name must be less than 100 characters.");
        
        RuleFor(x => x.Subject)
            .NotEmpty().WithMessage("Subject is required.")
            .MaximumLength(200).WithMessage("Subject must be less than 200 characters.");
        
        RuleFor(x => x.Body)
            .NotEmpty().WithMessage("Body is required.");
    }
}
```

4. **Atualizar o serviço para usar o template do banco de dados:**

```csharp
public class EmailTemplateService
{
    private readonly ApplicationDbContext _context;

    public EmailTemplateService(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<string> GetEmailTemplateAsync(string templateName)
    {
        var template = await _context.EmailTemplates
            .FirstOrDefaultAsync(t => t.TemplateName == templateName);

        return template?.Body;
    }

    public string ReplaceTokens(string template, Dictionary<string, string> tokens)
    {
        foreach (var token in tokens)
        {
            template = template.Replace($"{{{{{token.Key}}}}}", token.Value);
        }
        return template;
    }
}
```

5. **Atualizar o método `SendWelcomeEmailAsync` para usar o template dinâmico:**

```csharp
private readonly EmailTemplateService _emailTemplateService;

public UserService(ApplicationDbContext context, IEmailService emailService, EmailTemplateService emailTemplateService)
{
    _context = context;
    _emailService = emailService;
    _emailTemplateService = emailTemplateService;
}

private async Task SendWelcomeEmailAsync(ApplicationUser user)
{
    var subject = "Access Granted";
    var template = await _emailTemplateService.GetEmailTemplateAsync("WelcomeEmail");

    var tokens = new Dictionary<string, string>
    {
        { "AccessUrl", user.AccessUrl },
        { "Email", user.Email },
        { "Password", user.Password }
    };

    var body = _emailTemplateService.ReplaceTokens(template, tokens);

    await _emailService.SendEmailAsync(user.Email, subject, body);
}
```

Com essas etapas, você pode criar e validar templates de e-mail dinamicamente usando EF Core, Fluent API e FluentValidation. Se precisar de mais alguma coisa, estou à disposição!

Fonte: conversa com o Copilot, 01/10/2024
(1) 17 - Introduction to Fluent API | Code First | EF. https://www.youtube.com/watch?v=ZtWT5Zq2D28.
(2) 23 - Execute and Test Fluent API | Code First | EF6. https://www.youtube.com/watch?v=dvi_G-fiCuY.
(3) 21 - Configure One to Many Relationship in Fluent API | Code First | EF 6. https://www.youtube.com/watch?v=MJPClv_dff0.
(4) Entity Framework Core - Code First Approach With Fluent API - C# Corner. https://www.c-sharpcorner.com/article/entity-framework-core-code-first-approach-with-fluent-api/.
(5) Fluent API in Entity Framework Core. https://www.entityframeworktutorial.net/efcore/fluent-api-in-entity-framework-core.aspx.
(6) Real-Time Examples of Fluent API Validations in ASP.NET Core. https://dotnettutorials.net/lesson/real-time-examples-of-fluent-api-validations-in-asp-net-core-mvc/.
(7) FluentEmail - All in one email sender for .NET and .NET Core. https://github.com/lukencode/FluentEmail.
(8) Validation with FluentValidation in .NET Core 8.0 - C# Corner. https://www.c-sharpcorner.com/blogs/validation-with-fluentvalidation-in-net-core-80.




public class DatabaseAuditPersistenceService : IAuditPersistenceService
{
    private readonly DbContext _context;

    public DatabaseAuditPersistenceService(DbContext context)
    {
        _context = context;
    }

    public void SaveAuditEntries(IEnumerable<AuditDataEntityLog> auditEntries)
    {
        _context.Set<AuditDataEntityLog>().AddRange(auditEntries);
        _context.SaveChanges();
    }
}




Em C# .net 8 melhore a classe para que seja possivel salvar auditEntries que foram alteradas em log ou em um azure storage table chamando outras classes via injecao de dependencia assim como 
IAuditContextService e que seja facil parametrizar se sera salvo no banco de dados ou em outra forma como azure storage table ou log 

 public class AuditInterceptor : SaveChangesInterceptor, IAuditInterceptor
 {
     private readonly IAuditContextService _auditService;

     public AuditInterceptor(IAuditContextService auditService)
     {
         _auditService = auditService;
     }

     public override int SavedChanges(SaveChangesCompletedEventData eventData, int result)
     {
         var auditEntries = _auditService.OnBeforeSaveChanges(eventData.Context!);
          
         eventData!.Context!.Set<AuditDataEntityLog>().AddRange(auditEntries);
         return base.SavedChanges(eventData, result);
     }

     public override ValueTask<InterceptionResult<int>> SavingChangesAsync(DbContextEventData eventData, InterceptionResult<int> result, CancellationToken cancellationToken = default)
     {
         var auditEntries = _auditService.OnBeforeSaveChanges(eventData.Context!);
         eventData!.Context!.Set<AuditDataEntityLog>().AddRange(auditEntries);
         return base.SavingChangesAsync(eventData, result, cancellationToken);
     }



Para garantir que o log seja criado apenas quando houver exatamente uma entidade sendo modificada ou deletada, você pode adicionar uma verificação no início do método para contar as entradas relevantes. Se houver mais de uma, você pode retornar uma lista vazia. Aqui está uma versão melhorada do seu código:

```csharp
public List<AuditDataEntityLog> OnBeforeSaveChanges(DbContext context)
{
    var auditEntries = new List<AuditDataEntityLog>();

    // Filtra as entradas relevantes
    var relevantEntries = context.ChangeTracker.Entries()
        .Where(entry => entry != null && 
                        (entry.State == EntityState.Modified || entry.State == EntityState.Deleted))
        .ToList();

    // Verifica se há exatamente uma entrada relevante
    if (relevantEntries.Count != 1)
    {
        return auditEntries; // Retorna uma lista vazia se não houver exatamente uma entrada
    }

    // Cria o log para a única entrada relevante
    var auditEntry = CreateAuditEntry(relevantEntries.First());
    auditEntries.Add(auditEntry);

    return auditEntries;
}
```

Neste código, a lista `relevantEntries` é criada para armazenar apenas as entradas que estão em estado de modificação ou exclusão. Se o número de entradas relevantes não for exatamente um, o método retorna uma lista vazia. Caso contrário, ele cria o log para a única entrada relevante. Isso garante que o log seja criado apenas quando houver exatamente uma entidade sendo modificada ou deletada.

Fonte: conversa com o Copilot, 24/09/2024
(1) Como melhorar o desempenho de meu código com "for"?. https://pt.stackoverflow.com/questions/268296/como-melhorar-o-desempenho-de-meu-c%c3%b3digo-com-for.
(2) Tutorial Django Parte 8: Autenticação de usuário e permissões. https://developer.mozilla.org/pt-BR/docs/Learn/Server-side/Django/Authentication.
(3) GitHub - Daniel-Penelva/Projeto-livraria-APIRest-Spring-Boot .... https://github.com/Daniel-Penelva/Projeto-livraria-APIRest-Spring-Boot---estudando-relacionamento-entre-entidades.



Em C# net 8 qual melhor metodologia ou processo para gravar logs de registos de uma tabela do banco de dados sql  quero guardar os registros antes de efetuar um upade ou delete para que tenha um historico facil consultar e usar querys de consulta

Em vez de salvar no log tem outra forma e que seja segura para proteger de LGPD salvar no banco em uma tabela similar e usando o intercerptor para ficar bem reduzido o codigo e generico para qualquer tabela entidade

Melhore o codigo aplicando clean code e padroes de projeto e melhoria de performance e tambem deve guaradar o usuario que realizou essa atualizacao ou delete 

AuditLog deve ser codefirst com fluent api  e que seja possivel testar com teste unitario nunit


Para desacoplar o `AuditInterceptor` do `DbContext`, você pode seguir uma abordagem que utiliza injeção de dependência e serviços. Isso permitirá que o interceptor seja mais flexível e reutilizável. Aqui está uma versão melhorada do seu código:

```csharp
public class AuditInterceptor : SaveChangesInterceptor
{
    private readonly IAuditService _auditService;

    public AuditInterceptor(IAuditService auditService)
    {
        _auditService = auditService;
    }

    public override int SavedChanges(SaveChangesCompletedEventData eventData, int result)
    {
        var auditEntries = _auditService.OnBeforeSaveChanges(eventData.Context);
        eventData.Context.Set<AuditLog>().AddRange(auditEntries);
        return base.SavedChanges(eventData, result);
    }
}

public interface IAuditService
{
    List<AuditLog> OnBeforeSaveChanges(DbContext context);
}

public class AuditService : IAuditService
{
    private readonly IUserService _userService;

    public AuditService(IUserService userService)
    {
        _userService = userService;
    }

    public List<AuditLog> OnBeforeSaveChanges(DbContext context)
    {
        var auditEntries = new List<AuditLog>();
        foreach (var entry in context.ChangeTracker.Entries())
        {
            if (entry.State == EntityState.Modified || entry.State == EntityState.Deleted)
            {
                var auditEntry = new AuditLog
                {
                    TableName = entry.Entity.GetType().Name,
                    Operation = entry.State.ToString(),
                    KeyValues = JsonConvert.SerializeObject(entry.Properties.Where(p => p.Metadata.IsPrimaryKey())),
                    OldValues = entry.State == EntityState.Modified ? JsonConvert.SerializeObject(entry.OriginalValues.Properties.ToDictionary(p => p.Name, p => entry.OriginalValues[p])) : null,
                    NewValues = entry.State == EntityState.Modified ? JsonConvert.SerializeObject(entry.CurrentValues.Properties.ToDictionary(p => p.Name, p => entry.CurrentValues[p])) : null,
                    UserId = _userService.GetCurrentUserId()
                };
                auditEntries.Add(auditEntry);
            }
        }
        return auditEntries;
    }
}

public interface IUserService
{
    string GetCurrentUserId();
}

public class UserService : IUserService
{
    public string GetCurrentUserId()
    {
        // Implemente a lógica para obter o ID do usuário atual
        return "user-id-placeholder";
    }
}
```

### Alterações principais:
1. **Injeção de Dependência**: O `AuditInterceptor` agora recebe um `IAuditService` via injeção de dependência, tornando-o desacoplado do `DbContext`.
2. **Serviço de Auditoria**: A lógica de auditoria foi movida para um serviço separado (`AuditService`), que implementa a interface `IAuditService`.
3. **Serviço de Usuário**: A lógica para obter o ID do usuário atual foi movida para um serviço separado (`UserService`), que implementa a interface `IUserService`.

Essa abordagem melhora a testabilidade e a manutenção do código, além de seguir os princípios de responsabilidade única e inversão de dependência.

Fonte: conversa com o Copilot, 24/09/2024
(1) Log de auditoria com o Entity Framework 6 - Fabio Gouw. https://www.fabiogouw.com/2013/12/log-de-auditoria-com-o-entity-framework.html.
(2) Hibernate interceptor example - audit log - Mkyong.com. https://mkyong.com/hibernate/hibernate-interceptor-example-audit-log/.
(3) How to implement an audit interceptor in jdbi? - Stack Overflow. https://stackoverflow.com/questions/28039643/how-to-implement-an-audit-interceptor-in-jdbi.
(4) Configuring the audit interceptor - IBM. https://www.ibm.com/docs/en/zos-connect/zos-connect/3.0?topic=interceptors-configuring-audit-interceptor.
(5) Configuring Interceptors for z/OS Connect EE V3.0 FAQ - IBM. https://community.ibm.com/community/user/ibmz-and-linuxone/blogs/samantha-catling1/2020/08/11/configuring-interceptors-for-zos-connect-ee-v30-fa.

//=================
 Para implementar um sistema de auditoria em C# com .NET 8, que registre operações de atualização e exclusão em uma tabela de banco de dados SQL, você pode seguir os passos abaixo. Este exemplo utiliza Entity Framework Core, Fluent API, e NUnit para testes unitários. O objetivo é garantir que o código seja limpo, eficiente e em conformidade com a LGPD.

### 1. Defina a Entidade de Auditoria
```csharp
public class AuditLog
{
    public int Id { get; set; }
    public string TableName { get; set; }
    public string Operation { get; set; }
    public string KeyValues { get; set; }
    public string OldValues { get; set; }
    public string NewValues { get; set; }
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    public string UserId { get; set; } // Adicione o ID do usuário que realizou a operação
}
```

### 2. Crie um Interceptor de Salvamento
```csharp
public class AuditInterceptor : SaveChangesInterceptor
{
    private readonly DbContext _context;

    public AuditInterceptor(DbContext context)
    {
        _context = context;
    }

    public override int SavedChanges(SaveChangesCompletedEventData eventData, int result)
    {
        var auditEntries = OnBeforeSaveChanges();
        _context.Set<AuditLog>().AddRange(auditEntries);
        return base.SavedChanges(eventData, result);
    }

    private List<AuditLog> OnBeforeSaveChanges()
    {
        var auditEntries = new List<AuditLog>();
        foreach (var entry in _context.ChangeTracker.Entries())
        {
            if (entry.State == EntityState.Modified || entry.State == EntityState.Deleted)
            {
                var auditEntry = new AuditLog
                {
                    TableName = entry.Entity.GetType().Name,
                    Operation = entry.State.ToString(),
                    KeyValues = JsonConvert.SerializeObject(entry.Properties.Where(p => p.Metadata.IsPrimaryKey())),
                    OldValues = entry.State == EntityState.Modified ? JsonConvert.SerializeObject(entry.OriginalValues.Properties.ToDictionary(p => p.Name, p => entry.OriginalValues[p])) : null,
                    NewValues = entry.State == EntityState.Modified ? JsonConvert.SerializeObject(entry.CurrentValues.Properties.ToDictionary(p => p.Name, p => entry.CurrentValues[p])) : null,
                    UserId = GetCurrentUserId() // Método para obter o ID do usuário atual
                };
                auditEntries.Add(auditEntry);
            }
        }
        return auditEntries;
    }

    private string GetCurrentUserId()
    {
        // Implemente a lógica para obter o ID do usuário atual
        return "user-id-placeholder";
    }
}
```

### 3. Configure o Interceptor no Contexto
```csharp
public class ApplicationDbContext : DbContext
{
    private readonly AuditInterceptor _auditInterceptor;

    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options, AuditInterceptor auditInterceptor)
        : base(options)
    {
        _auditInterceptor = auditInterceptor;
    }

    public DbSet<AuditLog> AuditLogs { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.AddInterceptors(_auditInterceptor);
    }
}
```

### 4. Teste Unitário com NUnit
```csharp
[TestFixture]
public class AuditInterceptorTests
{
    private ApplicationDbContext _context;
    private AuditInterceptor _auditInterceptor;

    [SetUp]
    public void SetUp()
    {
        var options = new DbContextOptionsBuilder<ApplicationDbContext>()
            .UseInMemoryDatabase(databaseName: "TestDatabase")
            .Options;

        _auditInterceptor = new AuditInterceptor(new ApplicationDbContext(options, null));
        _context = new ApplicationDbContext(options, _auditInterceptor);
    }

    [Test]
    public void Should_Log_Audit_Entry_On_Update()
    {
        // Arrange
        var entity = new YourEntity { /* initialize properties */ };
        _context.Add(entity);
        _context.SaveChanges();

        // Act
        entity.SomeProperty = "New Value";
        _context.SaveChanges();

        // Assert
        var auditLog = _context.AuditLogs.FirstOrDefault();
        Assert.IsNotNull(auditLog);
        Assert.AreEqual("Modified", auditLog.Operation);
    }
}
```

### Melhorias de Clean Code e Performance
1. **Separação de Responsabilidades**: Separe a lógica de auditoria em uma classe de serviço dedicada.
2. **Uso de Async/Await**: Utilize métodos assíncronos para melhorar a performance.
3. **Injeção de Dependência**: Utilize DI para injetar o contexto e o interceptor.

### Exemplo de Serviço de Auditoria
```csharp
public class AuditService
{
    private readonly ApplicationDbContext _context;

    public AuditService(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task SaveAuditLogsAsync(List<AuditLog> auditLogs)
    {
        await _context.AuditLogs.AddRangeAsync(auditLogs);
        await _context.SaveChangesAsync();
    }
}
```

### Configuração do Serviço no Contexto
```csharp
public class ApplicationDbContext : DbContext
{
    private readonly AuditService _auditService;

    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options, AuditService auditService)
        : base(options)
    {
        _auditService = auditService;
    }

    public DbSet<AuditLog> AuditLogs { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.AddInterceptors(new AuditInterceptor(this));
    }

    public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        var auditEntries = OnBeforeSaveChanges();
        await _auditService.SaveAuditLogsAsync(auditEntries);
        return await base.SaveChangesAsync(cancellationToken);
    }

    private List<AuditLog> OnBeforeSaveChanges()
    {
        // Lógica de auditoria
    }
}
```

Com essas melhorias, você terá um sistema de auditoria robusto, eficiente e em conformidade com a LGPD. Se precisar de mais alguma coisa, estou aqui para ajudar!




Para implementar um sistema de auditoria em C# com .NET 8 que registre alterações antes de um `UPDATE` ou `DELETE`, você pode seguir os passos abaixo. Este método utiliza interceptores para capturar as mudanças e armazená-las em uma tabela de auditoria, garantindo conformidade com a LGPD.

### 1. Defina a Entidade de Auditoria
```csharp
public class AuditLog
{
    public int Id { get; set; }
    public string TableName { get; set; }
    public string Operation { get; set; }
    public string KeyValues { get; set; }
    public string OldValues { get; set; }
    public string NewValues { get; set; }
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    public string UserId { get; set; } // Adicione o ID do usuário que realizou a operação
}
```

### 2. Crie um Interceptor de Salvamento
```csharp
public class AuditInterceptor : SaveChangesInterceptor
{
    private readonly DbContext _context;

    public AuditInterceptor(DbContext context)
    {
        _context = context;
    }

    public override int SavedChanges(SaveChangesCompletedEventData eventData, int result)
    {
        var auditEntries = OnBeforeSaveChanges();
        _context.Set<AuditLog>().AddRange(auditEntries);
        return base.SavedChanges(eventData, result);
    }

    private List<AuditLog> OnBeforeSaveChanges()
    {
        var auditEntries = new List<AuditLog>();
        foreach (var entry in _context.ChangeTracker.Entries())
        {
            if (entry.State == EntityState.Modified || entry.State == EntityState.Deleted)
            {
                var auditEntry = new AuditLog
                {
                    TableName = entry.Entity.GetType().Name,
                    Operation = entry.State.ToString(),
                    KeyValues = JsonConvert.SerializeObject(entry.Properties.Where(p => p.Metadata.IsPrimaryKey())),
                    OldValues = entry.State == EntityState.Modified ? JsonConvert.SerializeObject(entry.OriginalValues.Properties.ToDictionary(p => p.Name, p => entry.OriginalValues[p])) : null,
                    NewValues = entry.State == EntityState.Modified ? JsonConvert.SerializeObject(entry.CurrentValues.Properties.ToDictionary(p => p.Name, p => entry.CurrentValues[p])) : null,
                    UserId = GetCurrentUserId() // Método para obter o ID do usuário atual
                };
                auditEntries.Add(auditEntry);
            }
        }
        return auditEntries;
    }

    private string GetCurrentUserId()
    {
        // Implemente a lógica para obter o ID do usuário atual
        return "user-id-placeholder";
    }
}
```

### 3. Configure o Interceptor no Contexto
```csharp
public class ApplicationDbContext : DbContext
{
    private readonly AuditInterceptor _auditInterceptor;

    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options, AuditInterceptor auditInterceptor)
        : base(options)
    {
        _auditInterceptor = auditInterceptor;
    }

    public DbSet<AuditLog> AuditLogs { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.AddInterceptors(_auditInterceptor);
    }
}
```

### Melhoria de Performance e Clean Code
- **Use `AsNoTracking`** para consultas onde não é necessário rastrear mudanças.
- **Evite consultas desnecessárias** ao banco de dados.
- **Implemente padrões de projeto** como Repository e Unit of Work para melhor organização e manutenção do código.

### Segurança e LGPD
- **Criptografe dados sensíveis** antes de armazená-los.
- **Implemente controle de acesso** para garantir que apenas usuários autorizados possam visualizar os logs de auditoria.

Essa abordagem garante que você tenha um histórico detalhado das operações realizadas no banco de dados, com um código limpo e eficiente, além de estar em conformidade com a LGPD. Se precisar de mais detalhes ou tiver outras perguntas, estou aqui para ajudar!

Fonte: conversa com o Copilot, 24/09/2024
(1) A more flexible and enhanced way of logging in .NET 8. https://steven-giesel.com/blogPost/1add3827-4233-4e31-9ce9-bcc34d64e76f.
(2) Logging in .NET 8 with Serilog and Seq - DEV Community. https://dev.to/chinonsoike/logging-in-net-8-with-serilog-and-seq-34kn.
(3) Serilog Tutorial for .NET Logging: 16 Best Practices and Tips. https://stackify.com/serilog-tutorial-net-logging/.
(4) .NET Logging: The Only Tutorial and 14 Tips You Need to Know ... - Stackify. https://stackify.com/log4net-for-net-logging-the-only-tutorial-and-14-tips-you-need-to-know/.

























Para gravar logs de registros de uma tabela do banco de dados SQL em C# .NET 8, especialmente antes de realizar operações de **update** ou **delete**, você pode seguir uma abordagem estruturada usando Entity Framework Core (EF Core) e a biblioteca de logging do .NET. Aqui está um processo recomendado:

### 1. Configurar o Logging no .NET
Utilize a API de logging do .NET para configurar o registro de logs. Você pode usar o `Microsoft.Extensions.Logging` para isso. Aqui está um exemplo básico de configuração:

```csharp
using Microsoft.Extensions.Logging;

var loggerFactory = LoggerFactory.Create(builder => {
    builder.AddConsole();
    builder.AddDebug();
});

ILogger logger = loggerFactory.CreateLogger<Program>();
logger.LogInformation("Logging is configured.");
```

### 2. Implementar Interceptores no EF Core
Os interceptores do EF Core permitem interceptar operações de banco de dados, como **update** e **delete**, para registrar os dados antes que essas operações sejam executadas.

```csharp
public class AuditInterceptor : SaveChangesInterceptor
{
    private readonly ILogger<AuditInterceptor> _logger;

    public AuditInterceptor(ILogger<AuditInterceptor> logger)
    {
        _logger = logger;
    }

    public override int SavedChanges(SaveChangesCompletedEventData eventData, int result)
    {
        var context = eventData.Context;
        if (context == null) return result;

        var entries = context.ChangeTracker.Entries()
            .Where(e => e.State == EntityState.Modified || e.State == EntityState.Deleted);

        foreach (var entry in entries)
        {
            var entityName = entry.Entity.GetType().Name;
            var originalValues = entry.OriginalValues.Properties.ToDictionary(p => p.Name, p => entry.OriginalValues[p]);
            _logger.LogInformation($"Entity: {entityName}, Original Values: {JsonConvert.SerializeObject(originalValues)}");
        }

        return result;
    }
}
```

### 3. Registrar o Interceptor no Contexto do EF Core
Adicione o interceptor ao contexto do EF Core para que ele seja utilizado durante as operações de salvamento.

```csharp
public class AppDbContext : DbContext
{
    private readonly AuditInterceptor _auditInterceptor;

    public AppDbContext(DbContextOptions<AppDbContext> options, AuditInterceptor auditInterceptor)
        : base(options)
    {
        _auditInterceptor = auditInterceptor;
    }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.AddInterceptors(_auditInterceptor);
    }
}
```

### 4. Configurar a Injeção de Dependência
Certifique-se de configurar a injeção de dependência para o `AuditInterceptor` e o `ILogger`.

```csharp
public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddDbContext<AppDbContext>(options =>
            options.UseSqlServer("YourConnectionString"));

        services.AddSingleton<AuditInterceptor>();
        services.AddLogging(config => {
            config.AddConsole();
            config.AddDebug();
        });
    }
}
```

### Resumo
Essa abordagem permite que você registre os valores originais das entidades antes de realizar operações de **update** ou **delete**, facilitando a consulta e o histórico dos dados. Utilizando interceptores do EF Core e a biblioteca de logging do .NET, você pode criar um sistema robusto de auditoria para seu banco de dados.

Se precisar de mais detalhes ou tiver outras perguntas, estou aqui para ajudar!

Fonte: conversa com o Copilot, 24/09/2024
(1) Registro em log em C# - .NET | Microsoft Learn. https://learn.microsoft.com/pt-br/dotnet/core/extensions/logging.
(2) Registro em log e rastreamento – .NET - .NET | Microsoft Learn. https://learn.microsoft.com/pt-br/dotnet/core/diagnostics/logging-tracing.
(3) Visão geral do registro em log e interceptação – EF Core. https://learn.microsoft.com/pt-br/ef/core/logging-events-diagnostics/.
(4) Controlando o registro em log no .NET Framework. https://learn.microsoft.com/pt-br/dotnet/framework/performance/controlling-logging.
(5) Gravar registros de Logs em C# - Blog do Prof. Anderson. https://www.blogson.com.br/gravar-registros-de-logs-em-c/.




Em C# net 8 melhore o  metodo saveMemoryIfNotExists para recuperar em memoria todos registros nos ultimos 2 minutos que que seja igual ao  auditEntries informado pelo paramentro
se nao existir salva Set e se existir retorne TryGet

 private void saveMemoryIfNotExists(List<AuditDataEntityLog> auditEntries)
 {
     throw new NotImplementedException();
 }
 public abstract class AuditDataEntityLogBase : EntityBase 
 { 
     public string TableName { get; set; } = string.Empty;
     public string Operation { get; set; } = string.Empty;
     public string KeyValue { get; set; } = string.Empty;
     public string OldValues { get; set; } = string.Empty;
     public string NewValues { get; set; } = string.Empty;
     public DateTime AuditDate { get; set; } = DateTime.UtcNow;
     public string? UserAuditedLogin { get; set; } = null; 
     public User? UserAudited { get; set; }
     public long? UserAuditedId { get; set; }
 }
Consulta base 
 var existingEntries = GetExistingEntries(context, auditEntries);
 return auditEntries
     .Where(e => !existingEntries.Exists(a => e.AuditDate.Date == a.AuditDate.Date
         && e.AuditDate.Hour == a.AuditDate.Hour
         && e.AuditDate.Minute == a.AuditDate.Minute
         && a.TableName.Equals(e.TableName)
         && a.Operation.Equals(e.Operation)
         && a.KeyValue.Equals(e.KeyValue)
         && a.OldValues.Equals(e.OldValues)
         && a.NewValues.Equals(e.NewValues)
         ))
     .ToList();


public class MemoryCacheRepository : IMemoryCacheRepository
{
    private readonly IMemoryCache _memoryCache;
    private readonly MemoryCacheEntryOptions? _cacheOptions;
    public MemoryCacheRepository(IMemoryCache memoryCache, IOptions<CacheConfigurationDto> cacheConfig)
    {
        _memoryCache = memoryCache;
        CacheConfigurationDto _cacheConfig = cacheConfig.Value;
        if (_cacheConfig != null)
        {
            DateTime absoluteExpiration = DataHelper.GetDateTimeNow().AddHours(_cacheConfig.AbsoluteExpirationInHours).AddMinutes(_cacheConfig.AbsoluteExpirationInMinutes);
            _cacheOptions = new MemoryCacheEntryOptions
            {
                AbsoluteExpiration = absoluteExpiration,
                Priority = CacheItemPriority.High,
                SlidingExpiration = TimeSpan.FromMinutes(_cacheConfig.SlidingExpirationInMinutes)
            };
        }
    }
    public bool TryGet<T>(string cacheKey, out T? value)
    {
        bool isSuccessGet;
        isSuccessGet = _memoryCache.TryGetValue(cacheKey, out value);
        return isSuccessGet;
    }
    public bool Set<T>(string cacheKey, T value)
    {
        _memoryCache.Set(cacheKey, value, _cacheOptions);
        return true;
    }
    public bool Remove(string cacheKey)
    {
        _memoryCache.Remove(cacheKey);
        return true;
    }
}